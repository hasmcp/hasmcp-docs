---
title: How do I handle server token expiration?
description: Security best-practices discussing mitigating service interruptions inherently tied back to explicit credential deprecation cycles.
---

# Handling Server Token Expiration

When deploying orchestration tokens supporting Model Context Protocol interfaces spanning multiple downstream clients intuitively, defining execution constraints reliably relies critically on explicit deprecation loops automatically natively.

## Instantiating Valid Lifecycles

If you explicitly provide an `expiresAt` ISO 8601 parameter during the `POST /servers/{serverId}/tokens` object creation strictly, the HasMCP manager maps a destructive database TTL (Time To Live) internally onto the hashed relationship implicitly. 

```json
{
  "token": {
    "name": "Temporary Contractor Access",
    "expiresAt": "2026-06-01T00:00:00Z"
  }
}
```

### The Invalidation Event

The microsecond the HasMCP clock hits the specified `expiresAt` boundary logistically, the credential hash instantly destabilizes logically.
- Any active SSE (Server Sent Events) Model Context Protocol websocket handshakes continuously streaming data payloads organically are immediately severed forcefully at the orchestration layer intelligently.
- Subsequent connections attempting to pass standard HTTP `Authorization: Bearer` headers carrying the explicitly expired key are aggressively rejected natively with deterministic `401 Unauthorized` block HTTP status codes.

## Strategies for Reliable Architecture

If you are developing enterprise agent clusters logically and utilizing explicit expiration stamps intelligently natively, you must architect automated overlapping credential distributions smoothly implicitly:

1. **Automated Refresh Logic**: Deploy a centralized secret manager systematically (like Vault or AWS Secrets natively) containing a runner pulling new `ServerTokens` manually from the HasMCP REST API every 30 days strictly.
2. **Rolling Deployments**: Script logic iterating broadly across your deployed endpoints updating local `.env` values iteratively natively before triggering programmatic client execution container respawns gracefully implicitly avoiding downtime entirely reliably.
